\documentclass{article}
\usepackage[utf8]{inputenc}

\title{The Basic Transmission Control Protocol \\ \large{A Python Implementation}}
\author{Ron Hommelsheim \\ s1000522 \and Mantas Makelis \\ sXXXXXXX}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
This report outlines our implementation of the basic Transmission Control Protocol (bTCP). 
First, connection establishment and termination will be described, both employing a three-way handshake. This connection management will be illuminated in a finite state diagram.


\section{Finite State Machine}

\section{BTCP Socket Class}
Each socket gets initialised with a window size, a timeout value and a random sequence number.
A buffer will be created for each socket, with its given window size. 

\subsection{Handle Flow}
A socket should only extract messages when it is in a state to do so. A server, for example, cannot (and should not) receive any messages while it has not established a connection yet. 
This method implements a safe way of getting messages out of the buffer. It does so by returning a segment only if the segment carries a flag which is currently expected. Otherwise, it will ignore the message. 

\subsection{Post}
Here, a segment is simply created and sent. The method takes a sequence number, an acknowledgement number, a flag, and possibly data as a parameter.

\subsection{Acknowledge Post}
Here, an acknowledgement segment is sent (by using the \texttt{post} function) after setting the acknowledgement number which depends on the sequence number. It is called by the client during the three-way handshake and otherwise by the server.

\subsection{Valid ACK}
A socket must be able to evalute whether the received ACK is valid. It does so by computing the expected ACK number itself and equates it to the received ACK.

\subsection{Pack Segment}
The actual creation of a segment happens here. First, a header consisting of a sequence number, an acknowledgement number, a flag, a receiving window, which is the difference between the original window size and the buffers current capacity, the data size, and the checksum is packed. This totals 10 bytes, to which the payload is attached. The data which will be sent can only be upto 1008 bytes long. If it is shorter, the remaining bytes will be padded. If it is longer, an error will be thrown.

\subsection{Unpack Segment}
A segment will be unpacked into a dictionary with the fields of the header as keys, plus a key for the data.

\subsection{Valid Checksum}
A received checksum needs to be validated. This is done by calculating it and equating it with the received checksum.

\subsection{Calc Checksum}
This is a standard implementation of the calculation of a checksum

\subsection{Safe Incr}
Since the sequence - and acknowledgement numbers are limited by two bytes, we need to make sure that we don't spill over when we increment. Thus, a wraparound condition is introduced, using a modulo.


\section{Client Socket}
\subsection{Connect}

\subsection{Send}
\subsection{Disconnect}


\section{Server}

\section{Tests}

\section{Discussion}

\end{document}